/*LICENSE_START*/
/*
 *  Copyright 1995-2002 Washington University School of Medicine
 *
 *  http://brainmap.wustl.edu
 *
 *  This file is part of CARET.
 *
 *  CARET is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  CARET is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with CARET; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include "AlgorithmSurfaceCortexLayer.h"
#include "AlgorithmException.h"
#include "SurfaceFile.h"
#include "TopologyHelper.h"
#include "Vector3D.h"

#include <cmath>

using namespace caret;
using namespace std;

AString AlgorithmSurfaceCortexLayer::getCommandSwitch()
{
    return "-surface-cortex-layer";
}

AString AlgorithmSurfaceCortexLayer::getShortDescription()
{
    return "CREATE SURFACE APPROXIMATING A CORTICAL LAYER";
}

OperationParameters* AlgorithmSurfaceCortexLayer::getParameters()
{
    OperationParameters* ret = new OperationParameters();
    ret->addSurfaceParameter(1, "white-surface", "the white matter surface");
    
    ret->addSurfaceParameter(2, "pial-surface", "the pial surface");
    
    ret->addDoubleParameter(3, "location", "what volume fraction to place the layer at");
    
    ret->addSurfaceOutputParameter(4, "out-surface", "the output surface");
    
    ret->setHelpText(
        AString("The input surfaces must have node correspondence.  ") +
        "The output surface is generated by placing nodes between the two surfaces such that the enclosed volume within any small patch of the new and white surfaces " +
        "is the given fraction of the volume of the same patch between the pial and white surfaces " +
        "(i.e., specifying 0 would give the white surface, 1 would give the pial surface).  "
    );
    return ret;
}

void AlgorithmSurfaceCortexLayer::useParameters(OperationParameters* myParams, ProgressObject* myProgObj)
{
    SurfaceFile* myWhiteSurf = myParams->getSurface(1);
    SurfaceFile* myPialSurf = myParams->getSurface(2);
    float myVolFrac = myParams->getDouble(3);
    SurfaceFile* myOutSurf = myParams->getOutputSurface(4);
    AlgorithmSurfaceCortexLayer(myProgObj, myWhiteSurf, myPialSurf, myVolFrac, myOutSurf);
}

AlgorithmSurfaceCortexLayer::AlgorithmSurfaceCortexLayer(ProgressObject* myProgObj, const SurfaceFile* myWhiteSurf, const SurfaceFile* myPialSurf, const float& myVolFrac, SurfaceFile* myOutSurf) : AbstractAlgorithm(myProgObj)
{
    LevelProgress myProgress(myProgObj);
    int numNodes = myWhiteSurf->getNumberOfNodes();
    if (numNodes != myPialSurf->getNumberOfNodes())
    {
        throw AlgorithmException("input surfaces have different number of nodes");
    }
    *myOutSurf = *myWhiteSurf;//copy topology
    myOutSurf->setSecondaryType(SecondarySurfaceTypeEnum::MIDTHICKNESS);//???
    const float* whiteCoords = myWhiteSurf->getCoordinateData();
    const float* pialCoords = myPialSurf->getCoordinateData();
    bool outside = false;
    bool above = false;
    if (myVolFrac < 0 || myVolFrac > 1)
    {
        outside = true;
        if (myVolFrac > 1) above = true;
    }
    CaretPointer<TopologyHelper> myTopoHelp = myWhiteSurf->getTopologyHelper();//trust that the input surfaces have the same topology
    for (int i = 0; i < numNodes; ++i)
    {
        Vector3D whiteCenter = whiteCoords + i * 3;
        Vector3D pialCenter = pialCoords + i * 3;
        float d1;
        Vector3D axisHat = (pialCenter - whiteCenter).normal(&d1);
        const vector<int32_t>& neighbors = myTopoHelp->getNodeNeighbors(i);
        int numNeigh = (int)neighbors.size();
        float accum = 0.0f;
        for (int j = 0; j < numNeigh; ++j)
        {
            Vector3D whiteNeighbor = whiteCoords + neighbors[j] * 3;
            Vector3D pialNeighbor = pialCoords + neighbors[j] * 3;
            float R0 = axisHat.cross(whiteCenter - whiteNeighbor).length();
            float RF = axisHat.cross(pialCenter - pialNeighbor).length();
            float Rd = RF - R0;
            float h0 = axisHat.dot(whiteCenter - whiteNeighbor);
            float hF = axisHat.dot(pialCenter - pialNeighbor);
            float hd = hF - h0;
            float a = R0 * (3 * d1 * R0 + 2 * h0 * Rd - 2 * hd * R0);//coefficient for t
            float b = Rd * (3 * d1 * R0 + h0 * Rd - hd * R0);//t^2
            float c = d1 * Rd * Rd;//t^3
            float fullVol = a + b + c;//trivial to evaluate for t = 1, and t = 0 gives 0
            float target = fullVol * myVolFrac;
            float lowt = 0, lowval = 0, hight = 1, highval = fullVol;
            if (outside)
            {
                if (above)
                {
                    if (Rd / R0 < 0)
                    {
                        hight = min(-R0 / Rd, 1 + (myVolFrac - 1) * 3);//because conical volumes are 1/3 the equivalent cylinder
                    } else {
                        hight = myVolFrac;//because the longest result here is cylinder
                    }
                    highval = hight * (a + hight * (b + hight * c));
                } else {
                    if (Rd / R0 > 0)
                    {
                        lowt = max(-R0 / Rd, myVolFrac * 3);//ditto
                    } else {
                        lowt = myVolFrac;
                    }
                    lowval = lowt * (a + lowt * (b + lowt * c));
                }
            }//these ranges SHOULD make the function monotonic
            const float TOLER = 0.0001f;//stop when high and low bounds are this close
            const int MAX_ITERS = 100;//but don't take too long trying to get there
            int iter = 0;
            while (abs(hight - lowt) > TOLER && iter < MAX_ITERS)
            {
                ++iter;
                float highdiff = (highval - target);
                float lowdiff = (target - lowval);
                float guess = (lowt * highdiff + hight * lowdiff) / (highdiff + lowdiff);//weighted average to get guess
                float highcap = (lowt + 9 * hight) / 10.0f;//make guess lie in the middle 80%, to make sure it always moves nontrivially
                float lowcap = (9 * lowt + hight) / 10.0f;
                if ((guess < lowcap) == (lowt < hight)) guess = lowcap;//in case positive t produces negative volume
                if ((guess > highcap) == (lowt < hight)) guess = highcap;
                float guessval = guess * (a + guess * (b + guess * c));
                if ((guessval < target) == (lowt < hight))
                {
                    lowt = guess;
                    lowval = guessval;
                } else {
                    hight = guess;
                    highval = guessval;
                }
            }
            float highdiff = (highval - target);//one more iteration to get the value to add to accum
            float lowdiff = (target - lowval);
            float guess = (lowt * highdiff + hight * lowdiff) / (highdiff + lowdiff);
            float highcap = (lowt + 9 * hight) / 10.0f;
            float lowcap = (9 * lowt + hight) / 10.0f;
            if (guess < lowcap) guess = lowcap;
            if (guess > highcap) guess = highcap;
            accum += guess;
        }
        accum /= numNeigh;
        myOutSurf->setCoordinate(i, accum * (pialCenter - whiteCenter) + whiteCenter);
    }
}

float AlgorithmSurfaceCortexLayer::getAlgorithmInternalWeight()
{
    return 1.0f;//override this if needed, if the progress bar isn't smooth
}

float AlgorithmSurfaceCortexLayer::getSubAlgorithmWeight()
{
    //return AlgorithmInsertNameHere::getAlgorithmWeight();//if you use a subalgorithm
    return 0.0f;
}
