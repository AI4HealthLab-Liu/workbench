
/*LICENSE_START*/
/*
 * Copyright 2012 Washington University,
 * All rights reserved.
 *
 * Connectome DB and Connectome Workbench are part of the integrated Connectome
 * Informatics Platform.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the names of Washington University nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*LICENSE_END*/

#define __CLASS_AND_NAME_HIERARCHY_GROUP_GENERATED_KEY_DECLARE__
#include "GroupAndNameHierarchyGroupGeneratedKey.h"
#undef __CLASS_AND_NAME_HIERARCHY_GROUP_GENERATED_KEY_DECLARE__

#include "CaretAssert.h"

using namespace caret;



/**
 * \class caret::GroupAndNameHierarchyGroupGeneratedKey
 * \brief Maintains selection of a class and name in each 'DisplayGroupEnum'.
 * The name's "key" is generated by this class and returned when a name is added.
 */

/**
 * Constructor.
 * @param name
 *    The name.
 * @param key
 *    Key assigned to the name.
 */
GroupAndNameHierarchyGroupGeneratedKey::GroupAndNameHierarchyGroupGeneratedKey(const AString& name,
                                                                               const int32_t key)
: GroupAndNameHierarchyGroup(name,
                             key)
{
    this->clear();
}

/**
 * Destructor.
 */
GroupAndNameHierarchyGroupGeneratedKey::~GroupAndNameHierarchyGroupGeneratedKey()
{
    this->clear();
}

/**
 * Clear the contents of this class selector.
 */
void
GroupAndNameHierarchyGroupGeneratedKey::clear()
{
    GroupAndNameHierarchyGroup::clear();
    
    /* Note: parent class' clear() method deletes all name selectors, so just clear vector */
    this->keyToNameSelectorVector.clear();
    
    this->availableNameKeys.clear();
}

/**
 * Add a name to the hierarchy.  If the name is already used in the selector,
 * its key is returned.  Otherwise, the name is added and a new key is returned.
 *
 * @param name
 *    Name that is added.
 * @return Key for name.
 */
int32_t
GroupAndNameHierarchyGroupGeneratedKey::addName(const AString& name)
{
    int32_t nameKey = -1;
    
    GroupAndNameHierarchyName* nameSelector = this->getNameSelectorWithName(name);
    if (nameSelector != NULL) {
        nameKey = nameSelector->getKey();
    }
    else {
        if (this->availableNameKeys.empty()) {
            nameKey = static_cast<int32_t>(this->keyToNameSelectorVector.size());
            nameSelector = new GroupAndNameHierarchyName(name, nameKey);
            this->keyToNameSelectorVector.push_back(nameSelector);
        }
        else {
            nameKey = this->availableNameKeys.front();
            this->availableNameKeys.pop_front();
            CaretAssert(this->keyToNameSelectorVector[nameKey]);
            nameSelector = new GroupAndNameHierarchyName(name, nameKey);
            this->keyToNameSelectorVector[nameKey] = nameSelector;
        }
        this->addToNameSelectorMap(name, nameSelector);
    }
    CaretAssert(nameKey >= 0);
    nameSelector->incrementCounter();
    
    return nameKey;
}

/**
 * Get the name selector for the name with the given key.
 * @param nameKey
 *    Key for name.
 * @return
 *    Name selector for the given key or NULL if there
 *    is no name selector with the given key.
 */
GroupAndNameHierarchyName*
GroupAndNameHierarchyGroupGeneratedKey::getNameSelectorWithKey(const int32_t nameKey)
{
    if ((nameKey >= 0)
        && (nameKey < static_cast<int32_t>(this->keyToNameSelectorVector.size()))) {
        GroupAndNameHierarchyName* ns = this->keyToNameSelectorVector[nameKey];
        if (ns != NULL) {
            return ns;
        }
    }
    
    return NULL;
}

/**
 * Get the name selector for the name with the given key.
 * @param nameKey
 *    Key for name.
 * @return
 *    Name selector for the given key or NULL if there
 *    is no name selector with the given key.
 */
const GroupAndNameHierarchyName*
GroupAndNameHierarchyGroupGeneratedKey::getNameSelectorWithKey(const int32_t nameKey) const
{
    if ((nameKey >= 0)
        && (nameKey < static_cast<int32_t>(this->keyToNameSelectorVector.size()))) {
        GroupAndNameHierarchyName* ns = this->keyToNameSelectorVector[nameKey];
        if (ns != NULL) {
            return ns;
        }
    }
    
    return NULL;
}

/**
 * Clear (set to zero) counters for all names in this class.
 */
void
GroupAndNameHierarchyGroupGeneratedKey::clearAllNameCounters()
{
    for (std::vector<GroupAndNameHierarchyName*>::const_iterator iter = this->keyToNameSelectorVector.begin();
         iter != this->keyToNameSelectorVector.end();
         iter++) {
        GroupAndNameHierarchyName* ns = *iter;
        if (ns != NULL) {
            ns->clearCounter();
        }
    }
}

int32_t
GroupAndNameHierarchyGroupGeneratedKey::getNumberOfNamesWithCountersGreaterThanZero() const
{
    int32_t numberOfNamesWithCounterGreaterThanZero = 0;
    
    for (std::vector<GroupAndNameHierarchyName*>::const_iterator iter = this->keyToNameSelectorVector.begin();
         iter != this->keyToNameSelectorVector.end();
         iter++) {
        const GroupAndNameHierarchyName* ns = *iter;
        if (ns != NULL) {
            if (ns->getCounter() > 0) {
                numberOfNamesWithCounterGreaterThanZero++;
            }
        }
    }
    
    return numberOfNamesWithCounterGreaterThanZero;
}

/**
 * Remove any names that have a count equal to zero.
 */
void
GroupAndNameHierarchyGroupGeneratedKey::removeNamesWithCountersEqualZero()
{
    const int32_t numberOfNames = static_cast<int32_t>(this->keyToNameSelectorVector.size());
    /*
     * Loop to find names with counters equal to zero
     */
    for (int32_t i = 0; i < numberOfNames; i++) {
        GroupAndNameHierarchyName* ns = this->keyToNameSelectorVector[i];
        if (ns != NULL) {
            if (ns->getCounter() <= 0) {
                /*
                 * Remove name selector from the name to name selector map
                 */
                this->removeNameSelector(ns);
                
                /*
                 * Delete the name selector and add index to available keys
                 */
                delete ns;
                this->keyToNameSelectorVector[i] = NULL;
                this->availableNameKeys.push_front(i);
            }
        }
    }
}
