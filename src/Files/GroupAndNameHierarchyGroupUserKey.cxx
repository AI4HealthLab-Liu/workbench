
/*LICENSE_START*/
/*
 * Copyright 2012 Washington University,
 * All rights reserved.
 *
 * Connectome DB and Connectome Workbench are part of the integrated Connectome 
 * Informatics Platform.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the names of Washington University nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*LICENSE_END*/

#define __CLASS_AND_NAME_HIERARCHY_GROUP_USER_KEY_DECLARE__
#include "GroupAndNameHierarchyGroupUserKey.h"
#undef __CLASS_AND_NAME_HIERARCHY_GROUP_USER_KEY_DECLARE__

#include "GroupAndNameHierarchyName.h"

using namespace caret;


    
/**
 * \class caret::GroupAndNameHierarchyGroupUserKey
 * \brief Maintains selection of a class and name in each 'DisplayGroupEnum'.
 * The name's "key" is generated by this class and returned when a name is added.
 */

/**
 * Constructor.
 * @param name
 *    The name.
 * @param key
 *    Key assigned to the name.
 */
GroupAndNameHierarchyGroupUserKey::GroupAndNameHierarchyGroupUserKey(const AString& name,
                                                                                               const int32_t key)
: GroupAndNameHierarchyGroup(name,
                                                        key)
{
    this->clear();
}

/**
 * Destructor.
 */
GroupAndNameHierarchyGroupUserKey::~GroupAndNameHierarchyGroupUserKey()
{
    this->clear();
}

/**
 * Clear the contents of this class selector.
 */
void
GroupAndNameHierarchyGroupUserKey::clear()
{
    GroupAndNameHierarchyGroup::clear();
    
    /* Note: parent class' clear() method deletes all name selectors, so just clear map */
    this->keyToNameSelectorMap.clear();
}

/**
 * Add a name and key to the hierarchy.  Note, a name may be associated
 * with more than one key for this type of selector.
 *
 * @param name
 *    Name that is added.
 * @param nameKey
 *    Key associated with the name.
 * @param iconRGB
 *    RGB color components for icon (may be NULL if no colors available)
 */
void
GroupAndNameHierarchyGroupUserKey::addNameWithKey(const AString& name,
                                                  const int32_t nameKey,
                                                  const float* iconRGB)
{
    /*
     * Does selector with key exist?
     */
    GroupAndNameHierarchyName* nameSelector = this->getNameSelectorWithKey(nameKey);
    if (nameSelector != NULL) {
        const int32_t existingNameKey = nameSelector->getKey();
        
        /*
         * Does key match? If so, do not need to make any changes and exit.
         */
        if (existingNameKey == nameKey) {
            return;
        }
        
        /*
         * Remove the name selector since key exists and replace it
         */
        this->removeNameSelector(nameSelector);
        this->keyToNameSelectorMap.erase(existingNameKey);
        delete nameSelector;
    }
    
    nameSelector = new GroupAndNameHierarchyName(name, nameKey);
    if (iconRGB != NULL) {
        nameSelector->setIconColorRGBA(iconRGB);
    }
    this->addToNameSelectorMap(name, nameSelector);
    this->keyToNameSelectorMap.insert(std::make_pair(nameKey, nameSelector));
}

/**
 * Get the name selector for the name with the given key.
 * @param nameKey
 *    Key for name.
 * @return
 *    Name selector for the given key or NULL if there
 *    is no name selector with the given key.
 */
GroupAndNameHierarchyName*
GroupAndNameHierarchyGroupUserKey::getNameSelectorWithKey(const int32_t nameKey)
{
    std::map<int32_t, GroupAndNameHierarchyName*>::iterator iter = this->keyToNameSelectorMap.find(nameKey);
    if (iter != this->keyToNameSelectorMap.end()) {
        GroupAndNameHierarchyName* ns = iter->second;
        return ns;
    }
    
    return NULL;
}

/**
 * Get the name selector for the name with the given key.
 * @param nameKey
 *    Key for name.
 * @return
 *    Name selector for the given key or NULL if there
 *    is no name selector with the given key.
 */
const GroupAndNameHierarchyName*
GroupAndNameHierarchyGroupUserKey::getNameSelectorWithKey(const int32_t nameKey) const
{
    std::map<int32_t, GroupAndNameHierarchyName*>::const_iterator iter = this->keyToNameSelectorMap.find(nameKey);
    if (iter != this->keyToNameSelectorMap.end()) {
        GroupAndNameHierarchyName* ns = iter->second;
        return ns;
    }
    
    return NULL;
}

/**
 * Clear (set to zero) counters for all names in this class.
 */
void
GroupAndNameHierarchyGroupUserKey::clearAllNameCounters()
{
    /* not used */
}

int32_t
GroupAndNameHierarchyGroupUserKey::getNumberOfNamesWithCountersGreaterThanZero() const
{
    /* not used */
    return 1;
}

/**
 * Remove any names that have a count equal to zero.
 */
void
GroupAndNameHierarchyGroupUserKey::removeNamesWithCountersEqualZero()
{
    /* not used */
}
